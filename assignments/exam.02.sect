<section name="exam-02"><title>Exam 2: ADTs, Algorithms, and Data Structures</title>

<para>
  Assigned: &wed08;
</para>

<para>
  Electronic and printed versions due: 10:00 a.m., &fri09;. 
</para>

<section name="prelim"><title>Preliminaries</title>

<section name="format"><title>Exam Format</title>

<para>
  This is a take-home examination. You may use any time or times you deem
  appropriate to complete the exam, provided you return it to me by the
  due date.
</para>

<para>
  There are four problems on this examination. You must do your best
  to answer all of them.  The problems are not necessarily
  of equal difficulty. Problems may include subproblems. If you
  complete four problems correctly or mostly correctly, you will 
  earn an A.  If you complete three problems correctly or mostly
  correctly, you will earn a B.  If you complete two problems
  correctly or mostly correctly, you will earn a C.  If you complete
  one problem correctly or mostly correctly, you will earn a D.
  If you complete fewer than one problem correctly or mostly
  correctly, you will earn an F.  If you do not attempt the examination,
  you will earn a 0.  Partially correct solutions may or may not earn
  you a partial grade, depending on the discretion of the grader.
</para>

<para>
  <emphasis>Read the entire examination before you begin.</emphasis>
</para>

<para>
  I expect that someone who has mastered the material and works at a
  moderate rate should have little trouble completing the exam in a
  reasonable amount of time. In particular, this exam is likely to take
  you about six hours, depending on how well you've learned the topics
  and how fast you work.  (When I do the problems, I will report how
  long each one took me.)
</para>

</section> <!-- format -->

<section name="honesty"><title>Academic Honesty</title>

<para>
  This examination is open book, open notes, open mind, open computer,
  and open Web. However, it is closed person. That means you should
  not talk to other people about the exam. Other than as restricted by
  that limitation, you should feel free to use all reasonable resources
  available to you.
</para>

<para>
  As always, you are expected to turn in your own work. If you find ideas
  in a book or on the Web, be sure to cite them appropriately. If you use
  code that you wrote for a previous lab or homework, cite that lab or
  homework and the other members of your group. If you use code that you
  found on the course Web site, be sure to cite that code. You need not
  cite the code provided in the body of the examination.
</para>

<para>
  Although you may use the Web for this exam, you may not post your
  answers to this examination on the Web.  (You certainly should not post
  them to GitHub.)  And, in case it's not clear, you may not ask others
  (in person, via email, via IM, via IRC, by posting a <quote>please
  help</quote> message, or in any other way) to put answers on the Web.
</para>

<para>
  Because different students may be taking the exam at different times,
  you are not permitted to discuss the exam with anyone until after I have
  returned it. If you must say something about the exam, you are allowed
  to say <quote>This is among the hardest exams I have ever taken. If
  you don't start it early, you will have no chance of finishing the
  exam.</quote> You may also summarize these policies. You may not tell
  other students which problems you've finished. You may not tell other
  students how long you've spent on the exam.
</para>

<para>
  You must include both of the following statements on the cover sheet
  of the examination.
</para>

<orderedlist>
  <listitem>
    I have neither received nor given inappropriate assistance on 
    this examination.
  </listitem>
  <listitem>
     I am not aware of any other students who have given or received 
     inappropriate assistance on this examination. 
  </listitem>
</orderedlist>

<para>
  Please sign and date each statement separately. Note that the statements
  must be true; if you are unable to sign either statement, please talk to
  me at your earliest convenience. You need not reveal the particulars of
  the dishonesty, simply that it happened. Note also that inappropriate
  assistance is assistance from (or to) anyone other than Professor
  Rebelsky (that's me).
</para>

</section> <!-- honesty -->

<section name="presentation"><title>Presenting Your Work</title>

<para>
  You must present your exam to me in two forms, physically and
  electronically.  If you fail to turn in both versions, you are unlikely
  to receive credit for the examination.
</para>

<para>
  <emphasis>Physical copy:</emphasis> 
  You must write all of your answers using the computer, print them out,
  number the pages; put your name on the top of every page, write, sign,
  and date each of the academic honesty statements (provided you are able
  to do so); and hand me the printed copy or put it under my office door.
  If you fail to name and number the printed pages, you may suffer
  a penalty.  If you fail to turn in a legible version of the exam,
  you are also likely to suffer some sort of penalty.
</para>

<para>
  <emphasis>Electronic copy:</emphasis>
  You must also submit an electronic copy of your exam.  You should
  create the electronic version by making a tarball of any relevant code
  and emailing me the tarball.  Here are the steps for making a tarball.
</para>

<orderedlist>
  <listitem>
    Remove any cruft (needless files) from your directory structure.
    I don't want to see <code>.class</code> files, editor backups,
    or anything similar.
  </listitem>

  <listitem>
    Switch to the <emphasis>parent</emphasis> directory of your
    exam directory.
  </listitem>

  <listitem>
    Issue the command <code>tar cvzf <emphasis>username</emphasis>.tgz 
    <emphasis>directory</emphasis></code>.
  </listitem>

  <listitem>
    If you have done things correctly, you should see the file
    <code><emphasis>username</emphasis>.tgz</code>.
  </listitem>

  <listitem>
    Make sure that the tar file contains the appropriate contents using
    the command <code>tar tvf <emphasis>username</emphasis>.tgz</code>.
    For example, if I were to check my tarball, I might see something like
    the following.

<screen>
&gt; <userinput>tar tvf rebelsky.tgz</userinput>
rebelsky/
rebelsky/.git/
rebelsky/.gitignore
rebelsky/Problem1/
rebelsky/Problem2/
rebelsky/Problem3/
rebelsky/Problem4/
rebelsky/README.md
rebelsky/Problem1/.classpath
rebelsky/Problem1/.project
rebelsky/Problem1/src/
rebelsky/Problem1/src/Quicksorter.java
rebelsky/Problem1/src/SamTest.java
rebelsky/Problem2/.classpath
rebelsky/Problem2/.project
rebelsky/Problem2/src/
reblesky/Problem2/src/Example1.java
reblesky/Problem2/src/Example2.java
reblesky/Problem2/src/Example3.java
...
</screen>
  </listitem>
</orderedlist>

<para>
  <emphasis>Code:</emphasis> In many problems, I ask you to write
  code. Unless I specify otherwise in a problem, you should write
  working code and include examples that show that you've tested
  the code.  You should do your best to format that code to the class
  formatting standards.  <emphasis>I am likely to subtract at least half
  the value of any problem in which your code does not adhere closely
  to the standards.</emphasis>
</para>

<para>
  <emphasis>Documentation:</emphasis> You should document classes,
  interfaces, fields, and methods using Javadoc-style comments.
  You should specify preconditions and postconditions for each method.
</para>

<para>
  <emphasis>Care:</emphasis>
  Just as you should be careful and precise when you write code and
  documentation, so should you be careful and precise when you write
  prose. Please check your spelling and grammar. Since I should be equally
  careful, the whole class will receive one point of extra credit for each
  error in spelling or grammar you identify on this exam. I will limit
  that form of extra credit to five points.
</para>

<para>
  <emphasis>Partial Credit:</emphasis>
  I may give partial credit for partially correct answers. I am best
  able to give such partial credit if you include a clear set of work
  that shows how you derived your answer. You ensure the best possible
  grade for yourself by clearly indicating what part of your answer is
  work and what part is your final answer.
</para>

</section> <!-- presentation -->

<section name="getting-help"><title>Getting Help</title>

<para>
  I may not be available at the time you take the exam. If you feel that
  a question is badly worded or impossible to answer, note the issue
  you have observed and attempt to reword the question in such a way that
  it is answerable.  You should also feel free to send me electronic mail
  at any time of day.
</para>

<para>
  I will also reserve time at the start of each class before the exam is
  due to discuss any general questions you have on the exam.
</para>

</section> <!-- getting-help -->

</section> <!-- prelim -->

<section name="preparation"><title>Preparation</title>

<para>
  Clone the repository using the following command, which will help
  ensure that you have the correct directory structure.  Note that
  I've set things up so that you can treat each problem as a separate
  Eclipse project.  <emphasis>Please do not make one project for the
  whole exam.</emphasis>.  Note also that the command will clone the
  repository into a directory that corresponds to your user name.
</para>

<screen>
$ git clone https://github.com/Grinnell-CSC207/exam2-2014S *username*
</screen>

</section> <!-- preparation -->

<section name="problems-02"><title>Problems</title>

<section id="dutch-quicksort"><title>Problem 1: Dutch Quicksort</title>

<para>
  <emphasis>Topics:</emphasis> Sorting. Quicksort. the Dutch National
  Flag Algorithm.
</para>

<para>
  Quinn and Sol are a bit frustrated by our current implementation
  of Quicksort.  They say <quote>Quicksort seems to do a lot of extra
  work when the pivot appears multiple times in the array.  Why can't
  we just group all of the elements equal to the pivot together, and
  only recurse on the values that are strictly smaller and strictly
  larger?</quote>
</para>

<para>
  Duff, Nat, and Fran say <quote>That seems to be a task for the
  Dutch National Flag algorithm, which can partition an array into
  three sections: red, white, and blue, or smaller, equal, and larger.</quote>
</para>

<para>
  Write a version of Quicksort that uses this approach.  That is,
  it should partition the array into three parts and only recurse on
  the left and right subparts.
</para>

<para>
  <emphasis>Note:</emphasis> You may find it difficult to make the
  partition process a separate method, since, in addition to rearranging
  the items in the subarray, it now has to return two values: the lower
  bound and upper bound of the middle part of the subarray.  Here are
  three options for dealing with that issue:  (1) You can move the
  partitioning process into the middle of Quicksort.  (2) You can write
  a helper procedure that, given the start of the middle subarray, finds
  the end.  (3) You can write a helper class that holds two integers
  and return an object in that class.  I tend to use the first approach.
</para>

</section> <!-- dutch-quicksort -->

<section id="filtering"><title>Problem 2: Filtering</title>

<para>
  <emphasis>Topics:</emphasis> Iterators.  Predicates.  Iteration.
  Anonymous inner classes.  Generics.  Object-oriented design.
</para>

<para>
  Your classmates, Phil and Holden, have enjoyed many aspects of
  object oriented design, but also like to think functionally.  They've
  started to look at approaches to working with iterators and 
  predicates.
</para>

<para>
  They note that it's relatively simple to print out all of the
  values for which a predicate holds.  For example,
</para>

<programlisting>
<xi:include href="../git/exam2-2014S/Problem2/src/Example1.java" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"
/></programlisting>

<para>
  But they'd like to play a bit more with the design.  Phil starts
  by noting that it would be useful to combine an iterator with a
  predicate to make what he calls a <quote>filtered iterator</quote>.
  A filtered iterator works much like an iterator, except that it
  only returns the values in the iteration for which the predicate holds.
</para>

<programlisting>
<xi:include href="../git/exam2-2014S/Problem2/src/Example2.java" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"
/></programlisting>

<para>
  Holden suggests that if we're going to make such use of predicates,
  we really should have tools for making new predicates.  He suggests
  ways to negate predicates and to combine predicates with and and or. 
  He also suggests making simple numeric
  predicates.  He even creates a handy-dandy code sketch.
</para>

<programlisting>
<xi:include href="../git/exam2-2014S/Problem2/src/Pred.java" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"
/></programlisting>

<para>
  Holden admits that this approach is a bit less object-oriented than
  one might hope.  After all, shouldn't <methodname>and</methodname>
  be a method of the <methodname>Predicate</methodname> interface, with
  each predicate able to combine itself with a parameter predicate?
  But they've decided that static methods can still provide a relatively
  object-oriented approach, and making every predicate implement
  <methodname>and</methodname> seems excessive.
</para>

<para>
  They've also come up with a host of utility classes, example, experiments, 
  and tests that you can find on Github.
</para>

<para>
  Unfortunately, Phil and Holden are better at concept and experiments
  than they are at details, so they've turned to you for the
  implementation.
</para>

<para>
  a. Implement the <methodname>FilteredIterator</methodname> class.
</para>

<para>
  b. Implement the methods in <code>Pred.java</code>.
</para>

</section> <!-- filtering -->

<section id="sorted-lists"><title>Problem 3: Sorted Lists</title>

<para>
  <emphasis>Topics:</emphasis> Linked structures. Skip lists.
  Iterators.  ADT design.
</para>

<para>
  Soren and Lisa claim to have enjoyed our exploration of lists.
  However, they note 
</para>

<blockquote>
  We thought that when we first started talking about lists, someone said
  that <quote>lists are ordered collections</quote>.  If they're ordered,
  shouldn't they use a comparator to specify the ordering?
</blockquote>

<para>
  With some effort, you explain to them that the ordering is determined
  by the client, rather than a separate iterator.  They reply,
</para>

<blockquote>
  Fine.  If you refuse to follow a sensible design, we'll come up with
  our own ADT.  A <emphasis>sorted list</emphasis> is a collection of
  values that are iterated from smallest to largest.  We use sorted
  lists when we need to prioritize things (e.g., we can process things
  from most important to least important by iterating the list) and when
  we need to quickly identify the <quote>best</quote> few values (e.g.,
  the top five scoring students).  Sorted lists should provide an
  <code><methodname>add</methodname>(T <parameter>value</parameter>)</code>
  method and a method for getting an iterator.  Clients remove elements
  with the iterator's <methodname>remove</methodname> method.  We'll leave 
  the complexities of full list iterators to another day.
</blockquote>

<para>
  As you might expect, your instructor, Hugh DeWitt, wants you to
  implement their design.  Fortunately, you have a working version of skip
  lists which Lisa and her friend Skippy developed previously.  Hence,
  your primary goal is to create a subclass that adds an iterator to
  skip lists.  You should not change the skip list code.  You will, however,
  probably need to have your iterator reference the fields of the skip
  list class.  (Let's hope that your classmates chose the right protection
  levels.)
</para>

<para>
  Note that the iterator's <methodname>hasNext</methodname> and
  <methodname>next</methodname> methods should all be O(1).  (Yes, you
  can pretend the height of a skip list is constant.)  The iterator's
  <methodname>remove</methodname> method should be at least as efficient
  as the skip list <methodname>remove</methodname> method.
</para>

</section> <!-- sorted-lists -->

<section id="kth-smallest"><title>Problem 4: The Kth Smallest Value</title>

<para>
  <emphasis>Topics:</emphasis> Linked structures. Doubly-linked
  lists.  Quicksort.  List iterators.
</para>

<para>
  Your classmates, Kay and Smilla, were intrigued by the efficient
  median algorithm we developed in class. In case you've forgotten,
  the algorithm looks something like the following:
</para>

<literallayout>lb = 0
ub = values.length
while (true)
  int p = partition(values, lb, ub, order)
  if (p == k)
    return values(k)
  else if (p &lt; k)
    lb = p + 1
  else
    ub = p</literallayout>

<para>
  However, Kay and Smilla are disappointed that the algorithm worked
  only on arrays.  <quote>After all</quote>, they say, <quote>isn't
  the whole reason we have iterators is that we want to be able to do
  clever things with lists as well as arrays.</quote>  They suggest
  that we rewrite our algorithm to work with structures that have a
  <methodname>listIterator</methodname> method.
</para>

<para>
  Amazingly, Hugh DeWitt is a little bit concerned about their
  observation.  Hugh notes 
</para>

<blockquote>
  That's a great idea.  Unfortunately, to do something like partition 
  in lists, we need to be able to not only iterate forward and backward, 
  but also keep track of where in the list the lower bound and upper 
  bound are.  We could use integer indices, but that's potentially
  inefficient.  If the folks at Sun/Oracle had been sensible, they
  might have made <code>ListIterators</code> cloneable, but they
  didn't.
</blockquote>

<para>
  Kay and Smilla, not to be deterred, quickly whip up a
  <methodname>CloneableListIterator</methodname> interface
  and rewrite our <code>DoublyLinkedList</code> class so that
  its iterators are cloneable.
</para>

<programlisting>
<xi:include href="../git/exam2-2014S/Problem4/src/CloneableListIterator.java" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"
/></programlisting>

<programlisting>
<xi:include href="../git/exam2-2014S/Problem4/src/SimpleList.java" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"
/></programlisting>

<programlisting>
<xi:include href="../git/exam2-2014S/Problem4/src/SimpleListUtils.java" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"
/></programlisting>

<para>
  They are about to start work on the <methodname>kthSmallest</methodname>
  operation when Hugh DeWitt turns to you and say <quote>Kay and Smilla
  already did enough of the work.  They shouldn't have to implement this
  method.  Why don't you do it?</quote>
</para>

<para>
  Implement the <methodname>kthSmallest</methodname> algorithm for lists
  that support cloneable iterators.  Note that your implementation should
  have an expected running time of O(n), so you may not sort the list.
  However, you may rearrange the elements of the list.  You must also
  do the work with only a constant amount of extra memory, so you may
  not copy the list into an array.
</para>

</section> <!-- kth-smallest -->

</section> <!-- problems-02 -->

<section id="extra-02"><title>Extra Credit</title>

<para>
  You can earn a small amount of extra credit if you report on three
  interesting techniques or ideas you discover from reading my unit tests.
</para>

<para> 
  Include a file at the top level of your directory structure with your 
  comments on those techniques or ideas.
</para>

<para>
  You may also earn a small amount of extra credit if you show good
  git behavior (other than pushing your work to a public repository).
  Make sure to do relatively small commits and to include good commit
  message.
</para>

</section> <!-- extra-02 -->

<section name="q-and-a-02"><title>Questions and Answers</title>

<section id="qa-problem1"><title>Problem 1</title>

<para>
  <emphasis>How long did this problem take you?</emphasis>
</para>

<blockquote>
  When I first tried it (a few semesters ago), it took between fifteen 
  and twenty minutes.  About five minutes to write the invariant.  (Yes, I do
  write invariants when I'm solving things.)  About ten minutes to write the
  loop and the recursive calls.  A few minutes to fix the one bug in my
  code, which involved backwards comparisons.  Since I'd written DNF and
  Quicksort examples that semester, I seemed pretty quick, even though I
  did not refer explicitly to the examples.
</blockquote>

<blockquote>
  When I redid the problem this semester, it took ten minutes.
  Amazingly, my first solution was correct.
</blockquote>

<para>
  <emphasis>What are the most common student errors on this problem?</emphasis>
</para>

<blockquote>
  Some students forget that the pivot will move when they rearrange the
  array, and refer to it is <code>values[mid]</code> or something
  similar.  The traditional partition method moves the value to the
  beginning of the subarray so that we know where it is.  For DNF, you
  might just store it in a value.
</blockquote>

<blockquote>
  I sometimes see some off-by-one errors.
</blockquote>

</section> <!-- qa-problem1 -->

<section id="qa-problem2"><title>Problem 2</title>

<para>
  <emphasis>How long did this problem take you?</emphasis>
</para>

<blockquote>
  I forgot to record the time.  I'll solve it again and let you know.
  (Yes, enough time has passed that I'll be doing it <quote>from 
  scratch</quote> as it were.)  Okay, the second time took fifteen
  minutes, including a bit of playing with options.
</blockquote>

<para>
  <emphasis>Can we assume that every call to <methodname>next</methodname>
  is immediately preceded by a call to <methodname>hasNext</methodname>?</emphasis>
</para>

<blockquote>
  No.  Someone who <quote>knows</quote> the expected number
  of elements might just call <methodname>next</methodname> the
  appropriate number of times.  Or someone might just keeping calling
  <methodname>next</methodname> until they get an exception.
</blockquote>

<para>
  <emphasis>Can we assume that <methodname>next</methodname>
  is called at least once between any two calls to
  <methodname>hasNext</methodname>?</emphasis>
</para>

<blockquote>
  No.  A client might call <methodname>hasNext</methodname>, decide
  not to do anything immediately, and then call <methodname>hasnext</methodname>
  another time elsehwere in the code.
</blockquote>

<para>
  <emphasis>Will you write some unit tests for the
  <methodname>remove</methodname> method?</emphasis>
</para>

<blockquote>
  I'll try.
</blockquote>

</section> <!-- qa-problem2 -->

<section id="qa-problem3"><title>Problem 3</title>

<para>
  <emphasis>How long did this problem take you?</emphasis>
</para>

<blockquote>
  The basic implementation (using the underlying skip list 
  <methodname>remove</methodname> method) took me under ten minutes.
</blockquote>

<blockquote>
  Adding support for <quote>fail fast</quote> took less than five
  additional minutes.  (<quote>fail fast</quote> is optional.  I just
  wanted to see how hard it was to add.)
</blockquote>

<blockquote>
  I have not yet tried implementing <methodname>remove</methodname>
  directly.
</blockquote>

<para>
  <emphasis>Can we use our own implementation of skip lists?</emphasis>
</para>

<blockquote>
  Yes.  However, you do have to make it generic.
</blockquote>

<para>
  <emphasis>For the iterator's <methodname>remove</methodname> method,
  can we call the skip list <methodname>remove</methodname> method?</emphasis>
</para>

<blockquote>
  Yes, provided that you still keep the iterator at the right position
  in the list.
</blockquote>

<para>
  <emphasis>Do we need to worry about invalidating iterators when the list
  is mutated?</emphasis>
</para>

<blockquote>
  You are not required to invalidate iterators.
</blockquote>

<para>
  <emphasis>Soren and Lisa said <quote>We'll leave the complexities
  of full list iterators to another day.</quote>.  But you write that
  <quote>your primary goal is to create a subclass that adds an iterator
  to skip lists</quote>.  I'm confused.  Don't the two statements
  contradict each other?</emphasis>
</para>

<blockquote>
  No.  The full list iterator (well, <code>ListIterator</code>) 
  interface includes methods to move in both directions and to set
  the current element.  You don't need to do those additional operations,
  just the basic iterator (well, <code>Iterator</code>) methods:
  <methodname>hasNext</methodname>, <methodname>next</methodname>, and
  <methodname>remove</methodname>.
</blockquote>

<para>
  <emphasis>Since we have to iterate elements in order, do we need to keep
  track of the last value we returned and search for the next smallest
  value, as we did for one implementation of priority queues?</emphasis>
</para>

<blockquote>
  Such an implementation is unlikely to be O(1).  You should think more
  about the underlying data structure that we're using.
</blockquote>

</section> <!-- qa-problem3 -->

<section id="qa-problem4"><title>Problem 4</title>

<para>
  <emphasis>How long did this problem take you?</emphasis>
</para>

<blockquote>
  It took me forty minutes.  I was overconfident, and did not draw the
  pictoral loop invariants.  Since I didn't draw those invariants, I had
  an <quote>off by one</quote> error that took some time for me to catch.
</blockquote>

<para>
  <emphasis>Why did you give us both <code>SimpleList</code> and
  <code>DoublyLinkedList</code>?</emphasis>  Do we have to implement
  <methodname>kthSmallest</methodname> for both?
</para>

<blockquote>
  I want you to write code to an interface, rather than to an
  implementation.  However, in order to experiment with your code,
  you needean implementation.  Hence, I provide
  <code>DoublyLinkedList</code> as an implementation of
  <code>SimpleList</code> that you could use.  (I also thought you'd
  want to see a full implementation of doubly-linked lists.)  So, you
  only need to implement <methodname>kthSmallest</methodname> once,
  for <code>SimpleList</code>.  The wonders of polymorphism
  guarantee that it will also work for <code>DoublyLinkedList</code>.
</blockquote>

<para>
  <emphasis>Is this zero-based or one-based?  That is, is the smallest element
  what you get from <code>kthSmallest(0)</code> or
  <code>kthSmallest(1)</code>.</emphasis>
</para>

<blockquote>
  The postconditions say <quote>There are exactly k values smaller than
  val in the list.</quote>.  That implies that it's zero-based.
</blockquote>

<para>
  <emphasis>You say that you should have drawn loop invariants.  Any hints on
  drawing those invariants?</emphasis>
</para>

<blockquote>
  The conceptual model of iterators suggests that they fall
  <emphasis>between</emphasis> elements.  Hence, I'd make sure to
  draw a picture in which the iterators that mark the lower bound
  and upper bound are between elements.  Presumably, the lower bound
  will be before the first element in the range of values left to 
  process and the upper bound will be after the last element in that range.
</blockquote>

<blockquote>
  Since the <methodname>set</methodname> method uses the last value
  returned by the iterator, and list iterators are bidirectional, I'd
  also find a way to mark those elements.  (Such marking may not be useful
  for the invariant, but it will be useful for analyzing how the procedure
  is supposed to work.)
</blockquote> 

<blockquote>
  So, maybe something like the following.  The slash and backslash
  indicate the element just returned.
<programlisting>
... val - val - val ... val - val - val ... val - val - val ... val - val ...
        ^                  \^                   ^/                  ^
        |                   |                   |                   |
        lb                small               large                 ub
</programlisting>
</blockquote>

</section> <!-- qa-problem4 -->

<section id="misc"><title>Miscellaneous</title>

</section> <!-- misc -->

</section> <!-- q-and-a-02 -->

<section name="errata-02"><title>Errata</title>

<para>
  Here you will find errors of spelling, grammar, and design that students 
  have noted. Remember, each error found corresponds to a point of
  extra credit for everyone. I usually limit such extra credit to five
  points. However, if I make an astoundingly large number of errors,
  then I will provide more extra credit.
</para>

<para>
  I will not accept corrections for credit until after I have taken the
  examination out of draft mode.
</para>

<para>
  I will not credit corrections for text in the Q&amp;A and errata sections,
  since those are often written quickly to get information out to students.
  I may not credit corrections to grammatical mistakes in code.
</para>

<itemizedlist>
  <listitem>
    Gremlins changed "1" to "-2" in the comparator for <code>Point</code>
    objects.  [VB.  2 points]
  </listitem>
  <listitem>
    <quote>Shouldn't use use</quote> should be 
    <quote>Shouldn't they use</quote>. [SZ, 1 point]
  </listitem>
  <listitem>
    Sam neglected to remove the disclaimer at the start of the exam.
    [KN, 1 point].
  </listitem>
  <listitem>
    Sam used <quote>and</quote> and <quote>or</quote> as verbs, which
    abuses the English language.  (As in <quote>to or two predicates</quote>.)
    [GB, 1 point].
  </listitem>
  <listitem>
    Sam spelled <quote>list</quote> as <quote>ilst</quote>.
    [EW, 0 point, spelling correction in code].
  </listitem>
</itemizedlist>

</section> <!-- errata-02 -->

</section> <!-- exam02 -->
