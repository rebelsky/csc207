<section name="final"><title>Final Examination</title>

<para>
  Assigned: &tue14;
</para>

<para>
  Prologue due: 5:00 p.m., &mon1f;. 
  Electronic version due: noon, &thu1f;. 
  Signed academic honesty statement due: noon, &thu1f;.
</para>

<section name="prelim"><title>Preliminaries</title>

<section name="format"><title>Exam Format</title>

<para>
  This is a take-home examination. You may use any time or times you deem
  appropriate to complete the exam, provided you return it to me by the
  due date.
</para>

<para>
  This examination has a required <ulink
  url="http://bit.ly/207finalprologue">prologue</ulink> that must be completed
  by Monday afternoon.  The prologue is intended to help you think about
  the examination.
</para>

<para>
  There are five problems on this examination. You must do your best
  to answer all of them.  The problems are not necessarily
  of equal difficulty. Problems may include subproblems. If you
  complete five problems correctly or mostly correctly, you will 
  earn an A.  If you complete four problems correctly or mostly
  correctly, you will earn a B.  If you complete three problems
  correctly or mostly correctly, you will earn a C.  If you complete
  two problems correctly or mostly correctly, you will earn a D.
  If you complete fewer than two problems correctly or mostly
  correctly, you will earn an F.  If you do not attempt the examination,
  you will earn a 0.  Partially correct solutions may or may not earn
  you a partial grade, depending on the discretion of the grader.
</para>

<para>
  <emphasis>Read the entire examination before you begin.</emphasis>
</para>

<para>
  I expect that someone who has mastered the material and works at a
  moderate rate should have little trouble completing the exam in a
  reasonable amount of time. In particular, this exam is likely to take
  you about ten hours, depending on how well you've learned the topics
  and how fast you work.
</para>

</section> <!-- format -->

<section name="honesty"><title>Academic Honesty</title>

<para>
  This examination is open book, open notes, open mind, open computer,
  and open Web. However, it is closed person. That means you should
  not talk to other people about the exam. Other than as restricted by
  that limitation, you should feel free to use all reasonable resources
  available to you.
</para>

<para>
  As always, you are expected to turn in your own work. If you find ideas
  in a book or on the Web, be sure to cite them appropriately. If you use
  code that you wrote for a previous lab or homework, cite that lab or
  homework and the other members of your group. If you use code that you
  found on the course Web site, be sure to cite that code. You need not
  cite the code provided in the body of the examination.
</para>

<para>
  Although you may use the Web for this exam, you may not post your
  answers to this examination on the Web.  (You certainly should not post
  them to GitHub.)  And, in case it's not clear, you may not ask others
  (in person, via email, via IM, via IRC, by posting a <quote>please
  help</quote> message or question on StackOverflow or on any other site,
  or in any other way) to put answers on the Web.
</para>

<para>
  Because different students may be taking the exam at different times,
  and because some students will choose to take a makeup examination that
  involves redoing the problems, you are not permitted to discuss the exam
  with anyone until after I have indicated that it is acceptable to do so.
  If you must say something about the exam, you are allowed to say
  <quote>This is among the hardest exams I have ever taken. If you don't
  start it early, you will have no chance of finishing the exam.</quote>
  You may also summarize these policies. You may not tell other students
  which problems you've finished. You may not tell other students how
  long you've spent on the exam.
</para>

<para>
  You must turn in a sheet that includes both of the following statements.
</para>

<orderedlist>
  <listitem>
    I have neither received nor given inappropriate assistance on 
    this examination.
  </listitem>
  <listitem>
     I am not aware of any other students who have given or received 
     inappropriate assistance on this examination. 
  </listitem>
</orderedlist>

<para>
  Please sign and date each statement separately. Note that the statements
  must be true; if you are unable to sign either statement, please talk to
  me at your earliest convenience. You need not reveal the particulars of
  the dishonesty, simply that it happened. Note also that inappropriate
  assistance is assistance from (or to) anyone other than Professor
  Rebelsky (that's me).
</para>

</section> <!-- honesty -->

<section name="presentation"><title>Presenting Your Work</title>

<para>
  You need only present your exam to me electronically.
  You should create the electronic version by making a tarball of any
  relevant code and emailing me the tarball.  If you don't know how
  to make a tarball, let me know.  If you really don't want to make a
  tarball, you can make a zip file.  In either case, please make sure
  that the file unpacks into a single folder with your username.  That
  folder should four subfolders, one each for problems 1, 2, and 3, and
  a combined folder for problems 4 and 5.
</para>

<para>
  Unless specified otherwise in the problem, the
  <filename>.java</filename> files for each problem should be in a
  <filename>src</filename> subfolder of the problem folder, and should
  not have a <code>package</code> declaration.  You can also include
  <filename>.txt</filename> or <filename>.md</filename> files in each
  folder that have notes you would like me to read, answers to non-coding
  questions, and sample output from any experiments you conduct.  You may
  include a <filename>.txt</filename> or <filename>.md</filename> file
  in the top-level directory with general notes.
</para>

<para>
  In many problems, I ask you to write code. Unless I specify otherwise
  in a problem, you should write working code and include examples that
  show that you've tested the code.   You should do your best to format that
  code to the Sun/Oracle Java coding standards.  I am likely to take off
  one point (on a 100-point scale) for each formatting error that I note, 
  although I am also likely to allow up to three formatting errors without
  penalty.
</para>

<para>
  You should document classes, interfaces, fields, and methods using
  Javadoc-style comments.  
</para>

<para>
  Just as you should be careful and precise when you write code and
  documentation, so should you be careful and precise when you write
  prose. Please check your spelling and grammar. Since I should be equally
  careful, the whole class will receive one point of extra credit for each
  error in spelling or grammar you identify on this exam. I will limit
  that form of extra credit to five points.
</para>

<para>
  I may give partial credit for partially correct answers. I am best
  able to give such partial credit if you include a clear set of work
  that shows how you derived your answer. You ensure the best possible
  grade for yourself by clearly indicating what part of your answer is
  work and what part is your final answer.
</para>

</section> <!-- presentation -->

<section name="getting-help"><title>Getting Help</title>

<para>
  I may not be available at the time you take the exam. If you feel that
  a question is badly worded or impossible to answer, note the issue
  you have observed and attempt to reword the question in such a way that
  it is answerable.  You should also feel free to send me electronic mail
  at any time of day.
</para>

<para>
  I will also reserve time at the start of each class before the exam is
  due to discuss any general questions you have on the exam.
</para>

</section> <!-- getting-help -->

</section> <!-- prelim -->

<section name="preparation-final"><title>Preparation</title>

<para>
  Clone the repo using the following command, which will help ensure
  that you have the correct directory structure.  Note that I have
  tried to set things up so that you can treat each problem as a
  separate Eclipse project.
</para>

<screen>
$ git clone https://github.com/Grinnell-CSC207/final-2013F *username*
</screen>

</section> <!-- preparation-final -->

<section name="problems-final"><title>Problems</title>

<section id="invariants"><title>Problem 1: Invariants</title>

<para>
  <emphasis>Topics:</emphasis> Loops, Invariants, Arrays, 
  Partitioning, Heaps
</para>

<para>
  Varun and Ina understand why I like invariants, but have trouble
  writing their own, or at least maintaining them, so they've turned
  to you.
</para>

<para>
  a. They've started working on an alternate version of
  <code>partition</code> in which elements equal to the pivot can either
  be on the left side or the right side.  They don't like my standard
  approach, because they note that we sometimes swap a large element
  out of the large side and then back again.  They also get bothered
  that I don't include the upper-bound in the subarray.  Finally, they
  don't like that I indicate borders of cells, rather than the cells
  themselves.
</para>

<para>
  They decide that their invariant should be:
</para>

<programlisting>
+-+--------+---------+--------+
|p| &lt;= piv | unknown | &gt;= piv |
+-+--------+---------+--------+
 ^        ^           ^      ^
 |        |           |      |
 lb       small       large  ub
</programlisting>

<para>
  That is,
</para>

<itemizedlist>
  <listitem>
    The pivot is in <code>vals[lb]</code>.
  </listitem>

  <listitem>
    For all <code>i</code>, <code>lb+1</code> &lt;= <code>i</code> &lt;= <code>small</code>, <code>vals[i]</code> is less than or
     equal to the pivot.
  </listitem>

  <listitem>
   For all i, <code>large</code> &lt;= <code>i</code> &lt;= <code>ub</code>; <code>vals[i]</code> is greater than or
     equal to the pivot.
  </listitem>
</itemizedlist>

<para>
  They put all their work together as follows.
</para>

<programlisting>
    /**
     * Partition the elements between lb and ub, inclusive.
     *
     * @pre lb &lt;= ub.
     */
    static &lt;T&gt; int partition(T[] vals, int lb, int ub, Comparator&lt;T&gt; order) {
        // Put a pivot at the start of the subarray.
        swap(vals, lb, lb + (ub-lb)/2);

        // Set up the bounds
        int small = lb+1;
        int large = ub;

        while (small &lt;= large) {
            // Skip over small elements
            while ((small &lt;= large) 
                     &amp;&amp; (order.compare(vals[small], vals[lb]) &lt;= 0)) {
                 ++small;
            } // while
            // Observation: At this point, vals[small] is large

            // Skip over large elements
            while ((small &lt;= large)
                     &amp;&amp; (order.compare(vals[large], vals[lb]) &gt;= 0)) {
                 --large;
            } // while
            // Observation: At this point, vals[large] is small

            // We've reached large/small elements, swap 'em
            swap(vals, small++, large--);
        } // while

        // The element at position small is the last small element,
        // so we can swap it with the pivot.
        swap(vals, lb, small);
        return small;
   } // partition(T[], int, int, Comparator&lt;T&gt;)
</programlisting>

<para>
  Unfortunately, there are flaws in their analysis and implementation.
  Lupe, their class mentor, suggests that you help them by answering
  the following questions.
</para>

<para>
  i. Are <code>small</code> and <code>large</code> initialized
  correctly to ensure that the invariant holds at the start of
  the outer loop?
</para>

<para>
  ii. Is the test in the outer loop consistent with this loop
  invariant?
</para>

<para>
  iii. If the invariant holds at the start of the first inner loop,
  how, if at all, is it violated at the end of the first inner loop?
</para>

<para>
  iv. Given that expectation, how, if at all, might the invariant be
  violated at the end of the second inner loop?
</para>

<para>
  v. Given those expectations, does the final portion of the outer
  loop restore the loop invariant?
</para>

<para>
  vi. Within the outer and inner loops, are the array elements accessed
  in a way consistent with the loop invariant?
</para>

<para>
  vii. If we assume that the loop invariant holds at the end of the 
  main loop, is <code>vals[lb]</code> being swapped with the correct
  element?
</para>

<para>
  b. After you answer those questions, Lupe suggests that we <quote>think
  more like SamR</quote>.  In particular, Lupe suggests that we treat
  <code>small</code> and <code>large</code> more like borders.
</para>

<programlisting>
+-+--------+---------+--------+
|p| &lt;= piv | unknown | &gt;= piv |
+-+--------+---------+--------+
 ^          ^       ^        ^
 |          |       |        |
 lb         small   large    ub
</programlisting>

<itemizedlist>
  <listitem>
    The pivot is in <code>vals[lb]</code>.
  </listitem>

  <listitem>
    For all <code>i</code>, <code>lb+1</code> &lt;= <code>i</code> &lt; <code>small</code>, <code>vals[i]</code> is less than or
     equal to the pivot.
  </listitem>

  <listitem>
   For all i, <code>large</code> &lt; <code>i</code> &lt;= <code>ub</code>; <code>vals[i]</code> is greater than or
     equal to the pivot.
  </listitem>
</itemizedlist>

<para>
  Answer the same questions i to vii for this new invariant.
</para>

<para>
  c. Find as simple a correction as possible to fix the given code.
</para>

<para>
  d. Ina decides we all need more practice and notes that we have not 
  bothered to write an invariant for our iterative <code>Heap.swapUp</code> 
  method.  Write that invariant.
</para>

<para>
  e. Varun thinks we need even more practice and notes that we have
  not bothered to write an invariant for our iterative <code>swapDown</code>
  method.  Lupe reminds Varun that we've been using a recursive
  <code>Heap.swapDown</code> method.  Write or find an iterative
  <code>Heap.swapDown</code> method.
</para>

<para>
  f. Write an invariant for the <code>Heap.swapDown</code> method.
</para>

</section> <!-- invariants -->

<section id="annotating"><title>Problem 2: Adding Information to Data Structures</title>

<para>
  <emphasis>Topics:</emphasis> Dynamic Data Structures, Trees, Lists,
  Nodes, Recursive Processing
</para>

<para>
  Your classmates, Tate and Anna, note that we often want to calculate
  information about data structures.  They suggest that we extend the
  nodes in our favorite linked data structures, the list and the tree,
  with an additional field, <code>info</code>, that can hold an 
  arbitrary piece of information.  You can find their updated code
  in the exam repository.
</para>

<para>
  a. Anna notes that it might be useful to identify the distance of
  each node from the end of the list.  For example, in the list
  <code>{ a, b, c }</code>, the node that contains <code>a</code>
  is two from the end of the list, the node that contains <code>b</code>
  is one from the end of the list, and the node that contains
  <code>c</code> is 0 from the end of the list, since it's at the end
  of the list.
</para>

<para>
  To the linked list class, add a method, <code>computeDistances()</code>,
  that fills in the <code>info</code> field for each node with an
  <code>Integer</code> that represents the distance of that node from
  the end of the list.
</para>

<para>
  You may only iterate the list once in doing this computation.
  In particular, you may only set the <code>info</code> field of each
  node once and you may only access the <code>info</code> field of each
  node once.  
</para>

<para>
  In addition, you may not declare any variables that hold arrays or
  dynamic data structures and you may not create any new nodes.
</para>

<para>
  b. Tate, in response, suggests that we do something similar for
  trees.  Instead of filling in the distance to the end, he wants you
  to fill in the <emphasis>height</emphasis> of the node, the distance
  to the farthest leaf.
</para>

<para>
  To the BST class, add a method, <code>computeHeight()</code>, that
  fills in the <code>info</code> field for each node with an 
  <code>Integer</code> that represents the distance
  of that node to the farthest leaf that falls below that node.
</para>

<para>
  Once again, you may visit each node at most once in doing this
  computation.  In addition, you may not declare any variables that hold
  arrays or dynamic data structures and you may not create any new nodes.
</para>

<para>
  c. Anna, not to be outdone, suggests something a bit more interesting.
  Rather than adding a height, we should create a string that gives the
  keys in the subtree, in alphabetical order, separated by commas.
</para>

<para>
  To the BST class add a method, <code>computeKeySequences()</code>, that
  fills in the <code>info</code> field with a <code>String</code> that
  represents all of the keys in the subtree, in order, separated by
  commas.
</para>

<para>
  Once again, you should visit each node at most once.  And, once again,
  you may not declare any variables that hold arrays or dynamic data
  structures and you may not create any new nodes.
</para>

</section> <!-- annotation -->

<section id="by-hand"><title>Problem 3: Running Algorithms by Hand</title>

<para>
  <emphasis>Topics:</emphasis> Heaps, Hash Tables, Hash Codes
</para>

<para>
  I was talking about this course to my colleagues, Theodore and Tessa, at 
  a recent conference.  While they approved of our regular
  use of unit tests, they also noted that they prefer to see more
  <quote>white box</quote> testing, in which we look inside the
  algorithm to make sure that things are okay along the way.  <quote>After
  all,</quote> they suggest, <quote>a student could write something
  that gives the same output as a hash table, but does not organize
  the data correctly</quote>.  They suggested that I therefore give you
  some practice running algorithms <quote>by hand</quote>.
</para>

<para>
  a. Suppose we are working with strings, that our non-expandable hash
  table has a capacity of 20 elements, and we have chosen the primitive
  hash function of <quote>add the value of the first and last letter of
  the string, using the following chart</quote>.
</para>

<programlisting>
a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z
1  3  5  7  9  11 13 15 17 19 21 23 25 26 24 22 20 18 16 14 12 10 8  6  4  2
</programlisting>

<para>
  Show the state of
  the hash table after inserting the following ten strings in that order:
  "raynard", "russell", "charlie", "pamela", "george", "richard", "glenn",
  "howard", "samuel", and "john".  
  Use each of the following table construction policies (so show
  four different tables).
  If a policy makes it impossible to insert a particular string, note
  that impossibility.
</para>

<para>
  i. Bucketed (more than one value can be in the same location).
</para>

<para>
  ii. No buckets, linear probing, offset of subsequent multiples of
  7 for linear probe.
</para>

<para>
  iii. No buckets, quadratic probing (offsets of 1, 4, 9, 16, 25, 36, 49, ...
  from the original location).
</para>

<para>
  iv. No buckets, linear probing, using the value of the second character 
  to determine the offset.  (E.g., for "charlie", the offset would be
  multiples of 15 and for "pamela" the offset would be multiples of 1.)
</para>

<para>
  b. You may recall that the Heapsort algorithm works by turning an
  array into a heap, and then repeatedly swapping the element at the
  top of the heap to the end of the heap and restoring the heap.
</para>

<para>
  i. Show the state of the following array after we've run the heapify
  step, but before we've started swapping elements.  Assume that
  smallest values have highest priority (which means we will probably
  be sorting the array from largest to smallest).
</para>

<programlisting>
5, 1, 8, 2, 3, 7, 9, 4, 4, 6
</programlisting>

<para>
  ii. Suppose we start with the heap given in the following array.
</para>

<programlisting>
1, 2, 3, 2, 4, 8, 4, 6, 9, 5
</programlisting>

<para>
  Show the state of the array after we've swapped the three smallest
  values to the end, and restored the heap after each swap.
</para>

</section> <!-- by-hand -->

<section id="parsing-json"><title>Problem 4: Parsing JSON</title>

<para>
  <emphasis>Topics:</emphasis> JSON, ArrayLists
</para>

<para>
  Ray and Ari have almost finished the JSON homework, but are
  stumped on arrays.  Finish their implementation.
</para>

</section> <!-- parsing-json -->

<section id="printing-json"><title>Problem 5: Printing JSON Trees</title>

<para>
  <emphasis>Topics:</emphasis> Trees, Output, Recursion
</para>

<para>
  Prince Theresa has appreciated all of the lovely tree output
  we've generated with the approach of <quote>print the node, then
  print all the children indented slightly more</quote>.  PT would
  like to see us do the same with JSON.  PT suggests that each field
  of an object should be indented, and the value should be on a
  separate line, indented again.
</para>

<para>
  Extend Ray and Ari's code to print an appropriate tree.  Examples
  follow.  You may find that you present the fields in a different order.
</para>

<table>
  <tr>
    <th>Input</th>
    <th>Output</th>
  </tr>

  <tr>
    <td>
<programlisting>
{"Name":"Sam"}
</programlisting>
    </td>
    <td>
<programlisting>
Object
  Name:
    Sam
</programlisting>
    </td>
  </tr>

  <tr>
    <td>
<programlisting>
{"Name":"Sam","Job":{"Employer":"Grinnell","Title":
"Professor of Comp Sci","StartYear":1997}}
</programlisting>
    </td>
    <td>
<programlisting>
Object
  Name: 
    Sam
  Job: 
    Object
      Employer: 
        Grinnell
      Title: 
        Professor of Comp Sci
      StartYear:
        1997
</programlisting>
    </td>
  </tr>

  <tr>
    <td>
<programlisting>
{"Values":[5,1,2,9,3]}
</programlisting>
    </td>
    <td>
<programlisting>
Object
   Values: 
     [ 
       5
       1
       2
       9
       3
     ]
</programlisting>
    </td>
  </tr>

  <tr>
    <td>
<programlisting>
{"Students":[{"First":"John","Last":"Doe"},
{"First":"Jane", "Last":"Doe","Grades":[]}]}
</programlisting>
    </td>
    <td>
<programlisting>
Object
  Students: 
    [ 
      Object
        First:  
          John
        Last: 
          Doe
      Object
        First: 
          Jane
        Last: 
          Doe
        Grades:
          [
          ]
    ]
</programlisting>
    </td>
  </tr>

</table>

</section> 

</section> <!-- problems-final -->

<section name="citations"><title>Citations</title>

<para>
  Many problems on this examination are based closely on problems
  Henry Walker wrote for past semesters of CSC 207.  However, they
  are rephrased in my own style.
</para>

</section> <!-- citations -->

<section name="q-and-a-final"><title>Questions and Answers</title>

<section id="q-and-a-final-01"><title>Problem 1</title>

<para>
  For 1C, are we trying to fix the code given in 1A to match the
  invariants and such in 1A or 1B?
</para>

<blockquote>
  You are trying to fix the code so that it correctly partitions the array.
  You should determine which invariant helps you guarantee that result.
</blockquote>

<para>
  For 1E, what are the parameters that the
  <methodname>swapDown</methodname> procedure should take?
</para>

<blockquote>
  You have a sample <methodname>swapDown</methodname> procedure,
  don't you?  Traditionally, it takes the array, the size of the array,
  and the comparator.  In the recursive formulation, it was useful to
  take the position to swap down from as a parameter.  In the iterative
  version, you can use position 0, or you can include it as a parameter.
</blockquote>

<para>
  Could you explain again exactly what <methodname>swapUp</methodname>
  and <methodname>swapDown</methodname> do, so we have that information
  to reference in the actual exam?
</para>

<blockquote>
  <methodname>swapUp</methodname> restores a heap by taking an element that 
  is potentially too low in the heap and moving it up in the heap.
</blockquote>

<blockquote>
  <methodname>swapDown</methodname> restores a heap by taking an element 
  that is potentially too high in the heap and moving it down in the heap.
</blockquote>

<para>
  For 1F, should we write the invariant for the iterative or recursive 
  <methodname>Heap.swapDown</methodname> method?
</para>

<blockquote>
  Iterative.  Remember, it's a <emphasis>loop</emphasis> invariant.
</blockquote>

<para>
  Suppose I've found one issue in the <methodname>partition</methodname>
  method.  Do I really need to analyze the other issues?
</para>

<blockquote>
  Certainly.  Fixing that one issue may not fix the whole problem, and
  a good analyst tries to identify as many problems as possible.  Why?
  In part because understanding all of the problems will help you identify
  which problem is the most important, and will likely give you some ideas
  on how to fix that problem.
</blockquote>

<para>
  Please remimd me what you want for an invariant.
</para>

<blockquote>
  An invariant is a statement (well, a set of statements) about the
  state of the program such that if the invariant holds at the start
  of one iteration of the loop, it holds at the end of the iteration.
  Knowing that the iteration holds and that the loop has terminated
  should let you conclude that the postcondition of your procedure has
  been met.
</blockquote>

</section> <!-- q-and-a-final-01 -->

<section id="q-and-a-final-02"><title>Problem 2</title>

<para>
  For 2A, are we supposed to create a separate test/experiment class
  that actually calls the method we wrote, 
  <methodname>computeDistances</methodname>?
</para>

<blockquote>
  That would probably be a good idea.  You can also just extend the
  current experiment.
</blockquote>

</section> <!-- q-and-a-final-02 -->

<section id="q-and-a-final-03"><title>Problem 3</title>

<para>
  Can you remind me of the loop invariant for heap sort?
</para>

<blockquote>
  There are two primary invariants.  First, the array is divided
  into a heap portion and a sorted portion.
</blockquote>

<blockquote>
<programlisting>
  +------+--------+
  | Heap | Sorted |
  +------+--------+
</programlisting>
</blockquote>

<blockquote>
  Second, everything in the heap section is no higher priority than
  everything in the sorted section.  If we're sorting smallest to
  largest, all the things in the heap are less than or equal to the
  things in the sorted section.  If, as in the problem, we're sorting
  from largest to largest, all the things in the heap are greater than
  or equal to the things in the sorted section.
</blockquote>

<para>
  I understand that the algorithm sorts largest to smallest.  For
  b.ii, Can you
  show the state of the heap after, say, 8 swaps and reheaps?
</para>

<blockquote>
<programlisting>
+---+---+---+---+---+---+---+---+---+---+
| 8 | 9 | 6 | 5 | 4 | 4 | 3 | 2 | 2 | 1 | 
+---+---+---+---+---+---+---+---+---+---+
  Heap  |        Sorted
</programlisting>
</blockquote>

</section> <!-- q-and-a-final-03 -->

<section id="q-and-a-final-04"><title>Problem 4</title>

<para>
  I worry about the call to <code>info.next()</code> in the switch
  statement in <code>parseArray</code>.
</para>

<blockquote>
  I would agree with you that <code>info.next()</code> may not be
  the best idea.  However, the code in <code>parseArray</code> is just 
  a stub to get it to go through the array in a reasonable way during
  testing of other methods.  I didn't expect you to keep any of that code.
</blockquote>

<para>
  I approached the homework much differently.  Do you have any
  suggestions?
</para>

<blockquote>
  1. Throw away the stub.  It's intended as a stub, and not as anything
  resembling a solution.
</blockquote>

<blockquote>
  2. Take a look at the code for parsing an object, which should be
  similar to what you need to do for an array.
</blockquote>

</section> <!-- q-and-a-final-04 -->

<section id="q-and-a-final-05"><title>Problem 5</title>

<para>
  The object fields in my tree appear in a different order than
  they appear in the sample output.  Is that okay?
</para>

<blockquote>
  Certainly.  Since we're storing the fields in a hash table, we'll
  get them out of the hash table in whatever order the table uses.
  (We could also get them out in alphabetical order by getting all
  the keys, putting them in an array, and sorting that array, but 
  that seems a bit beyond the scope of this problem.)
</blockquote>

<para>
  How should the indent of subtrees relate to the indent of their
  parent?
</para>

<blockquote>
  Each additional indentation should be an additional two spaces.
</blockquote>

<para>
  What about those weirdo dashes that you put in the experiment?
</para>

<blockquote>
  That was just a convenient way to set off the tree.
</blockquote>

</section> <!-- q-and-a-final-5 -->

</section> <!-- q-and-a-final -->

<section name="errata-final"><title>Errata</title>

<para>
  Here you will find errors of spelling, grammar, and design that students 
  have noted. Remember, each error found corresponds to a point of
  extra credit for everyone. I usually limit such extra credit to five
  points. However, if I make an astoundingly large number of errors,
  then I will provide more extra credit.
</para>

<para>
  In general, I don't give credit for errors in the Q&amp;A section,
  the Errata section, or the experiments.
</para>

<itemizedlist>
  <listitem>
    <quote>Annotate</quote> is misspelled in <filename>LLExpt.java</filename>
    [JB, 0 points] (fixed, but in an experiment).
  </listitem>
  <listitem>
    Missing word in documentation in <filename>LinkedList.java</filename>.
    [JB, 1 point]
  </listitem>
  <listitem>
    The exam is unclear about whether we can build additional
    structures for 2C.  (Clarified.) [JB, 1 point]
  </listitem>
  <listitem>
    Typo in comment in sanity check in <methodname>parseObject</methodname>
    in <filename>parseObject</filename>. [ML, 1 point]
  </listitem>
  <listitem>
    Problem 3a has four different tables, not five. [EW, 1 point]
  </listitem>
  <listitem>
    In 1ai.vii, <code>a[lower]</code> appears instead of
    <code>vals[lower]</code>.  [AT, JB, 1 point]
  </listitem>
  <listitem>
    In 1, the topics include <quote>the Partitioning</quote> rather
    than <quote>Partitioning</quote> [JB, 0 points]
  </listitem>
  <listitem>
    In 1, the <code>vals</code> parameter to <code>swap</code> is 
    missing. [JB, AK, 0 points]
  </listitem>
</itemizedlist>

</section> <!-- errata-final -->

</section> <!-- final -->
